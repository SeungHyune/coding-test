# 삼각 그래프

[문제 링크](https://www.acmicpc.net/problem/4883)

### 문제

이 문제는 삼각 그래프의 가장 위쪽 가운데 정점에서 가장 아래쪽 가운데 정점으로 가는 최단 경로를 찾는 문제이다.

삼각 그래프는 사이클이 없는 그래프로 N ≥ 2 개의 행과 3열로 이루어져 있다. 삼각 그래프는 보통 그래프와 다르게 간선이 아닌 정점에 비용이 있다. 어떤 경로의 비용은 그 경로에서 지나간 정점의 비용의 합이다.

오른쪽 그림은 N = 4인 삼각 그래프이고, 가장 위쪽 가운데 정점에서 가장 아래쪽 가운데 정점으로 경로 중 아래로만 가는 경로의 비용은 7+13+3+6 = 29가 된다. 삼각 그래프의 간선은 항상 오른쪽 그림과 같은 형태로 연결되어 있다.

![trigraph.png](https://github.com/user-attachments/assets/74425384-3795-4a6a-9029-d5968dd8961c)

<br/>

### 입력

입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 그래프의 행의 개수 N이 주어진다. (2 ≤ N ≤ 100,000) 다음 N개 줄에는 그래프의 i번째 행에 있는 정점의 비용이 순서대로 주어진다. 비용은 정수이며, 비용의 제곱은 1,000,000보다 작다.

입력의 마지막 줄에는 0이 하나 주어진다.

<br/>

### 출력

각 테스트 케이스에 대해서, 가장 위쪽 가운데 정점에서 가장 아래쪽 가운데 정점으로 가는 최소 비용을 테스트 케이스 번호와 아래와 같은 형식으로 출력한다.

```jsx
k.n;
```

k는 테스트 케이스 번호, n은 최소 비용이다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
4
13 7 5
7 13 6
14 3 12
15 6 16
0

// 예제 출력 1
1. 22
```

<br/>

### 📕 문제 포인트

1. 무한 루프를 통해 테스트 케이스를 반복합니다.
   - N 값을 확인해 N이 0이면 루프를 종료합니다.
2. `dp 배열` 을 초기화합니다. `dp 배열` 은 현재까지의 최소 경로 합을 저장합니다.
   - `dp[0]` 은 무한대로 설정하여 경로 계산에 영향을 미칮 않도록 하고, dp[1]과 dp[2]는 첫 번째 행의 값으로 초기화합니다.
3. 2행부터 N행까지 반복하면서 현재 행(`cur`)의 값을 읽어옵니다.
   - `next` 배열을 생성하여 다음 행의 최소 경로 합을 계산합니다.
     - next[0]: 현재 행의 첫 번째 숫자를 선택할 때의 최소 경로 합
     - next[1]: 현재 행의 두 번째 숫자를 선택할 때의 최소 경로 합
     - next[2]: 현재 행의 세 번째 숫자를 선택할 때의 최소 경로 합
   - `dp배열`을 `next`로 업데이트합니다.
4. `input 배열`에서 현재 처리한 테스트 케이스를 제거합니다.
   - cnt와 함께 최소 경로 합(dp[1])을 출력합니다.
   - cnt를 증가시킵니다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync(0).toString().trim().split("\n");
let cnt = 1;

while (1) {
  const N = Number(input[0]);
  if (N == 0) break;

  let dp = input[1].split(" ").map(Number);
  dp = [Infinity, dp[1], dp[1] + dp[2]];
  for (let i = 2; i <= N; ++i) {
    const cur = input[i].split(" ").map(Number);
    const next = Array(3).fill(0);

    next[0] = Math.min(dp[0], dp[1]) + cur[0];
    next[1] = Math.min(dp[0], dp[1], dp[2], next[0]) + cur[1];
    next[2] = Math.min(dp[1], dp[2], next[1]) + cur[2];
    dp = next;
  }
  input.splice(0, N + 1);
  console.log(cnt + ".", dp[1]);
  ++cnt;
}
```
