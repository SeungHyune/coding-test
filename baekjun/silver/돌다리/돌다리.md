# **돌다리**

[문제 링크](https://www.acmicpc.net/problem/12761)

### 문제

동규와 주미는 일직선 상의 돌 다리 위에있다. 돌의 번호는 0 부터 100,000 까지 존재하고 동규는 N번 돌 위에, 주미는 M번 돌 위에 위치하고 있다. 동규는 주미가 너무 보고싶기 때문에 최대한 빨리 주미에게 가기 위해 A,B만큼의 힘을 가진 스카이 콩콩을 가져왔다. 동규가 정한 다리를 건너는 규칙은 턴 방식인데, 한 턴에 이동할 수 있는 거리는 이러하다. 현 위치에서 +1칸, -1칸을 이동할 수 있고, 스카이 콩콩을 이용해 현 위치에서 A나 B만큼 좌우로 점프할 수 있으며, 순간적으로 힘을 모아 현 위치의 A배나 B배의 위치로 이동을 할 수 있다. 예를 들어 지금 동규가 7번 돌 위에 있고 스카이 콩콩의 힘이 8이면 그냥 점프를 해서 15번 돌에 갈 수도 있고, 순간적으로 힘을 모아 56번 돌에 갈 수도 있다는 것이다. 주어진 8가지의 방법 중 적절한 방법을 골라서 최대한 빨리 동규가 주미를 만날 수 있게 도와주자. 단, 이동 과정에서 100,000보다 크거나 0보다 작은 번호의 돌은 존재하지 않으므로 갈 수 없고, 같은 방법을 계속 사용해도 되며 항상 도달할 수 있는 케이스만 주어진다.

<br/>

### 입력

입력의 첫 줄에 스카이 콩콩의 힘 A와 B, 그리고 동규의 현재위치 N, 주미의 현재 위치 M이 주어진다. (단, 2≤A,B≤30 이고 0≤N,M≤100,000)

<br/>

### 출력

동규가 주미에게 도달하기 위한 최소한의 이동 횟수를 출력하라.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
2 3 1 20

// 예제 출력 1
4
```

<br/>

### 📕 문제 포인트

1. 동규의 위치에서 최소한의 이동으로 주미에게 도달할 수 있는 이동 횟수를 출력하는 문제입니다.
2. 돌의 번호는 최대 100,000까지 존재하기 때문에 1차원 `dp` 배열을 `100001` 개 만들어줍니다.
   - 초깃값을 가장 큰 수인 `Infinity`로 설정해 줍니다.
3. 시작 지점(N)인 동규의 위치 `dp[N]`은 `0`으로 설정해 주고, queue에 N을 담고 BFS 탐색을 시작합니다.
4. 동규가 이동할 수 있는 위치는 8가지 방법입니다.
   - 현재 위치 - 1, 현재 위치 + 1
   - 현재 위치 + A, 현재 위치 - A, 현재 위치 + B, 현재 위치 - B
   - 현재 위치 _ A, 현재 위치 _ B
5. 동규가 이동할 수 있는 위치에 저장된 `dp` 값 보다 `dp[현재 위치] + 1`이 더 적은 경우에만 해당 지점으로 이동하여 다음 이동을 시작합니다.
6. 이렇게 모든 queue에 담긴 위치 정보가 사라진 후의 dp에 담긴 M 번 위치 값을 출력하면 됩니다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [A, B, N, M] = input.shift().split(" ").map(Number);

const dp = Array.from({ length: 100001 }, () => Infinity);
dp[N] = 0;

const queue = [N];

while (queue.length > 0) {
  const current = queue.shift();

  for (const next of [
    current - 1,
    current + 1,
    current * A,
    current * B,
    current + A,
    current - A,
    current + B,
    current - B,
  ]) {
    if (next < 0 || next > 100001) continue;

    if (dp[next] > dp[current] + 1) {
      dp[next] = dp[current] + 1;
      queue.push(next);

      if (next === M) {
        break;
      }
    }
  }
}

console.log(dp[M]);
```
