# **악수**

---

[문제 링크](https://www.acmicpc.net/problem/8394)

### 문제

회의가 끝났고, 이제 악수를 하는 시간이다. 모든 사람은 직사각형 탁자 하나의 한 면에 앉아있다.

자리를 벗어나지 않고 악수를 하는 방법의 수는 총 몇 가지일까?

각 사람들은 자신의 왼쪽이나 오른쪽에 있는 사람들과 악수를 할 수 있다. (안 할 수도 있다)

### 입력

첫째 줄에 회의에 참석한 사람의 수 n (1 ≤ n ≤ 10,000,000)이 주어진다.

### 출력

첫째 줄에 악수를 하는 방법의 수를 출력한다. 수가 매우 커질 수 있기 때문에, 마지막 자리만 출력한다.

### 예제 입력

```jsx
// 예제 입력 1
4;

// 예제 출력 1
5;
```

### 📕 문제 포인트

1. `dp` 배열을 `n + 1` 크기로 생성합니다.
   - 피보나치 수열의 마지막 자리 숫자를 저장하기 위한 배열
   - `dp[0]`과 `dp[1]`을 `1`로 초기화합니다.
2. 이제 n이 60보다 작은 경우 `n + 1` , 60보다 크거나 같은 경우 `60` 으로 지정한 다음 k가 N보다 작을 때까지 계산합니다.
   - `dp[k] = (dp[k-2] % 10 + dp[k-1] % 10) % 10`
   - 위 계산을 통해 피보나치 수의 마지막 자리 숫자만 저장합니다.
3. 최종적으로 `dp[n % 60]`을 출력하여, n이 60 이상일 경우에도 올바른 마지막 자리 숫자를 출력합니다.

### 📝 문제 풀이

```js
const fs = require("fs");
const n = fs.readFileSync("/dev/stdin").toString().trim();

if (n === 1) console.log(0);
else {
  let dp = new Array(n + 1);

  dp[0] = 1;
  dp[1] = 1;
  let N = n < 60 ? n + 1 : 60;
  for (let k = 2; k < N; ++k) {
    dp[k] = ((dp[k - 2] % 10) + (dp[k - 1] % 10)) % 10;
  }
  console.log(dp[n % 60]);
}
```
