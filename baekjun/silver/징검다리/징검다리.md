# **징검다리**

[문제 링크](https://www.acmicpc.net/problem/11561)

### 문제

승택이는 강을 건너려 한다.

승택이는 수영을 못하기 때문에, 강에 놓인 징검다리를 밟고 건너갈 것이다.

승택이는 수영은 못하지만 제자리뛰기는 정말 잘한다. 원하는 어느 곳으로든지 점프해서 바로 갈 수가 있다.

승택이는 이제 강의 한쪽 변 앞에 서 있다.

강엔 1번부터 시작해 2번, 3번, ... , N번 징검다리가 차례대로 놓여 있다.

강의 폭이 넓은 탓에 징검다리의 수는 엄청나게 많다.

이 징검다리를 모두 밟고 싶지는 않았던 승택이는 제자리뛰기 실력을 발휘해 적절한 개수의 징검다리만을 밟고 가기로 했다.

물론 강 건너편으로 바로 점프하는 것도 가능하지만, 더 재미있게 강을 건너기 위해 승택이는 다음과 같은 규칙을 정했다.

1. 첫 징검다리는 점프해서 아무 것이나 밟을 수 있다. 이 점프가 첫 점프이다.
2. 두 번째 점프부터는 이전에 점프한 거리보다 1 이상 더 긴 거리를 뛰어야만 한다.
3. N번 징검다리는 반드시 밟아야 한다.
4. N번 징검다리를 밟은 후 강 건너로 이동할 땐 점프를 하지 않으므로 위의 규칙이 적용되지 않는다.

승택이가 위의 규칙을 지키며 강을 건널 때, 밟을 수 있는 징검다리의 최대 수는 몇 개일까?

<br/>

### 입력

첫째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스는 정수 한 개로 이루어져 있으며, 징검다리의 총 수 N을 의미한다. (1 ≤ N ≤ 10^16)

<br/>

### 출력

각 테스트 케이스마다 한 줄에 승택이가 밟을 수 있는 최대 징검다리 수를 출력한다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
4;
1;
2;
100;
1000000;

// 예제 출력 1
1;
1;
13;
1413;
```

<br/>

### 📕 문제 포인트

1. 징검다리 수 `n` 에 대해 최대 몇 개의 징검다리를 밣을 수 있는지 계산합니다.
   - 두 번째 점프부터 이전 점프 거리보다 1이상 길게 뛰어야 한다.
   - `mid`번 점프를 한다고 했을 때 1부터 mid까지의 거리를 모두 더한 만큼 징검다리를 지나야 `mid`개의 징검다리를 밟을 수 있게 된다. 이 합은 `(mid * (mid + 1) / 2)`로 구할 수 있다.
2. `getSearch` 함수를 통해 `mid` 값을 찾습니다.
   - `left`는 가능한 최소 점프 횟수이며, `right`는 최대 징검다리 개수 `n`이다.
3. `while` 반복문으로 `mid` 값을 계산합니다.
   - 1부터 `mid`까지의 합을 구해, `sum` 값이 총 징검다리 수 `n` 보다 작거나 같으면, `mid`번 점프하는 것이 가능하거나 더 많이 점프할 수 있다.
   - 이때, `result`에 `mid`를 저장하고, `left`를 `mid + 1`로 옮겨서 더 작은 `mid` 값을 찾는다.
   - 이때, `left`가 `right` 보다 커질 때까지 반복하면, 1부터 `result`까지 더한 값이 `n`을 넘지 않는 최대 result 값을 찾을 수 있다.

### 📝 문제 풀이

```js
let input = require("fs")
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n");

const t = +input.shift();

let results = [];

function getSearch(n) {
  let left = 0;
  let right = n;
  let result = 0;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    let sum = (mid * (mid + 1)) / 2;

    if (sum <= n) {
      result = mid;
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return result;
}

for (let i = 0; i < t; i++) {
  let n = +input[i];
  results.push(getSearch(n));
}
console.log(results.join("\n"));
```
