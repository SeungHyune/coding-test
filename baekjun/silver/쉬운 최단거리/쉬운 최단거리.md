# **쉬운 최단거리**

[문제 링크](https://www.acmicpc.net/problem/14940)

### 문제

지도가 주어지면 모든 지점에 대해서 목표지점까지의 거리를 구하여라.

문제를 쉽게 만들기 위해 오직 가로와 세로로만 움직일 수 있다고 하자.

<br/>

### 입력

지도의 크기 n과 m이 주어진다. n은 세로의 크기, m은 가로의 크기다.(2 ≤ n ≤ 1000, 2 ≤ m ≤ 1000)

다음 n개의 줄에 m개의 숫자가 주어진다. 0은 갈 수 없는 땅이고 1은 갈 수 있는 땅, 2는 목표지점이다. 입력에서 2는 단 한개이다.

<br/>

### 출력

각 지점에서 목표지점까지의 거리를 출력한다. 원래 갈 수 없는 땅인 위치는 0을 출력하고, 원래 갈 수 있는 땅인 부분 중에서 도달할 수 없는 위치는 -1을 출력한다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
15 15
2 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 1 0 0 0
1 1 1 1 1 1 1 1 1 1 0 1 1 1 1

// 예제 출력 1
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
11 12 13 14 15 16 17 18 19 20 0 0 0 0 25
12 13 14 15 16 17 18 19 20 21 0 29 28 27 26
13 14 15 16 17 18 19 20 21 22 0 30 0 0 0
14 15 16 17 18 19 20 21 22 23 0 31 32 33 34
```

<br/>

### 📕 문제 포인트

1. 갈 수 있는 땅(`1` 번)으로 이동하며 목표 지점까지의 거리를 `N * M` 배열로 만들어서 출력하는 문제입니다.
2. `N * M` 크기의 `visited` 배열과 `result` 배열을 생성합니다.
   - `visited` 배열은 방문 체크를 검사하는 배열입니다.
   - `result` 배열은 각 지점에서 목표지점까지의 거리를 담는 배열입니다.
     - 초깃값은 모두 `-1`로 초기화합니다.
3. 지도의 값이 `0` 인 경우 원래 갈 수 없는 땅이기 때문에 `result[i][j]` 값을 `0`으로 수정해 줍니다.
4. 이미 방문한 경우와 갈 수 있는 `1` 인 경우에는 `continue` 문을 통해 반복을 넘겨줍니다.
5. 목표지점 `2` 인 경우 현재 위치를 `result[i][j]`로 `0`으로 바꾸고 목표지점부터 갈 수 있는 길인 `1`로 이동하며 거리를 측정합니다.
   - result[현재 위치][현재 위치] + 1로 이동할 수 있는 길을 탐색하며 `result`에 거리를 추가합니다.
6. 모든 반복문 종료 후 `result` 를 출력해 줍니다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [[N, M], ...arr] = input.map((a) => a.split(" ").map(Number));

const visited = Array.from({ length: N }, () =>
  Array.from({ length: M }, () => false)
);
const result = Array.from({ length: N }, () =>
  Array.from({ length: M }, () => -1)
);

const nx = [-1, 0, 1, 0];
const ny = [0, 1, 0, -1];

for (let i = 0; i < N; i++) {
  for (let j = 0; j < M; j++) {
    if (arr[i][j] === 0) {
      result[i][j] = 0;
      continue;
    }
    if (visited[i][j] || arr[i][j] === 1) continue;

    visited[i][j] = true;
    result[i][j] = 0;
    const queue = [[i, j, 0]];

    while (queue.length > 0) {
      const [x, y, l] = queue.shift();

      for (let k = 0; k < 4; k++) {
        const dx = x + nx[k];
        const dy = y + ny[k];

        if (dx < 0 || dy < 0 || dx >= N || dy >= M) continue;

        if (visited[dx][dy] || arr[dx][dy] === 0) continue;

        result[dx][dy] = l + 1;
        visited[dx][dy] = true;

        queue.push([dx, dy, l + 1]);
      }
    }
  }
}

console.log(result.join("\n").split(",").join(" "));
```
