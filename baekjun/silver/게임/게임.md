# 게임

[문제 링크](https://www.acmicpc.net/problem/1072)

### 문제

김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.

이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.

게임 기록은 다음과 같이 생겼다.

- 게임 횟수 : X
- 이긴 게임 : Y (Z%)
- Z는 형택이의 승률이고, 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z=88이다.

X와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 번 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.

<br/>

### 입력

각 줄에 정수 X와 Y가 주어진다.

<br/>

### 출력

첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.

<br/>

### 제한

- 1 ≤ X ≤ 1,000,000,000
- 0 ≤ Y ≤ X

<br/>

### 예제 입력

```jsx
// 예제 입력 1
99000 0

// 예제 출력 1
1000
```

<br/>

### 📕 문제 포인트

1. 형택이의 현재 승률 보다 증가하려면 몇 번의 게임을 더 진행해야 할지 구하는 문제입니다.
   - 단, 앞으로 진행하는 모든 게임은 승리한다.
2. 저는 이분 탐색 알고리즘을 통해 시간 복잡도를 낮췄습니다.
   - 이 문제에서 전체 게임 수의 최댓값이 1,000,000,000으로 mid 값을 1,000,000,000 이하로 맞춰 주었습니다.
   - start = 1 / end = 1,000,000,000 으로 시작했습니다.
3. 이제 start ≤ end && mid ≤ 1,000,000,000인 경우 반복되도록 반복문을 작성합니다.
4. `전체 경기 수 + mid` `이긴 경기 수 + mid` 더한 후 새로운 승률을 구합니다.
5. 만약 현재 승률이 최초의 승률보다 높다면 최솟값을 구해야 하기 때문에 end 값을 mid - 1 값으로 갱신하여 반복합니다.
6. 반복문이 종료되는 조건이 되었을 때의 mid 값은 min에 갱신되어 min 값을 구할 수 있습니다.
   - min 값은 -1로 시작하며, 만약 승률이 오르는 상황이 없다면 -1을 출력하게 됩니다.
7. 여기서 중요한 점은 컴퓨터의 실수를 구하는 방식에 있습니다.
   - 처음 승률 계산 공식 : Math.floor((이긴 경기 수 / 전체 경기 수) \* 100)
   - 수정 승률 계산 공식 : Math.floor((이긴 경기 수 \* 100) / 전체 경기 수)
   - 처음 승률을 계산한 방식 보다 수정한 방식이 실수를 계산하는 오차를 줄일 수 있다고 합니다.

### 📝 문제 풀이

```js
// 형택이의 게임횟수 X, 이긴횟수 Y가 주어질 때
// 현재 승률이 변하려면 몇 번 더 이겨야 하는지 승리의 최솟값을 구해라
// 앞으로 진행하는 게임은 무조건 승리한다.

// 전체 게임 횟수 : 88
// 지금까지 이긴 횟수 : 50
// 현재 승률 : Math.floor((50 / 88) * 100) = 56
// 56 => 57 되려면 몇 번 더 게임을 진행해야 하는가? (모든 게임은 무조건 이긴다.)
// 정답 : 1 => Math.floor((51 / 88) * 100) = 57

const fs = require("fs");
const [X, Y] = fs
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n")[0]
  .split(" ")
  .map(Number);
const Z = Math.floor((Y * 100) / X); // 현재 승률

let [start, end] = [1, 1000000000];
let mid = Math.floor((start + end) / 2);

let min = -1;

while (start <= end && mid <= 1000000000) {
  mid = Math.floor((start + end) / 2);

  const newZ = Math.floor(((Y + mid) * 100) / (X + mid));

  if (Z < newZ) {
    // 승률 상승 했기 때문에 더 작은 경기수를 찾아야함
    end = mid - 1;
    min = mid;
  } else {
    // 승률 그대로이기 때문에 더 많은 경기를 해야함
    start = mid + 1;
  }
}

console.log(min);
```
