# 빠른 숫자 탐색

[문제 링크](https://www.acmicpc.net/problem/25416)

### 문제

5 x 5 크기의 보드가 주어진다. 보드는 1 x 1 크기의 정사각형 격자로 이루어져 있다. 보드의 격자에는 **-1, 0, 1**중 하나의 숫자가 적혀 있다. 격자의 위치는 (_r_, *c*)로 표시한다. *r*은 행 번호, *c*는 열 번호를 나타낸다. 행 번호는 맨 위 위치가 0이고 아래 방향으로 1씩 증가한다. 열 번호는 맨 왼쪽 위치가 0이고 오른쪽 방향으로 1씩 증가한다. 즉, 맨 왼쪽 위 위치가 (0, 0), 맨 아래 오른쪽 위치가 (4, 4)이다. -1이 적혀 있는 칸으로는 이동할 수 없고 0, 1이 적혀 있는 칸으로는 이동할 수 있다.

현재 한 명의 학생이 (_r_, *c*) 위치에 있고 한 번의 이동으로 상, 하, 좌, 우 방향 중에서 한 방향으로 한 칸 이동할 수 있다. **학생이 현재 위치 (_r_, *c*)에서 시작하여 1이 적혀 있는 칸에 도착하기 위한 최소 이동 횟수를 출력하자.** 현재 위치 (_r_, *c*)에서 시작하여 1이 적혀 있는 칸으로 이동할 수 없는 경우 –1을 출력한다. 보드에는 1이 적혀 있는 격자가 1개 주어진다.

<br/>

### 입력

첫 번째 줄부터 다섯 개의 줄에 걸쳐 보드의 정보가 순서대로 주어진다. *i*번째 줄의 *j*번째 숫자는 보드의 (*i* - 1)번째 행, (*j* - 1)번째 열의 정보를 나타낸다. 보드의 정보는 -1, 0, 1중 하나이다.

다음 줄에 학생의 현재 위치 *r*, *c*가 빈칸을 사이에 두고 순서대로 주어진다.

<br/>

### 출력

학생이 현재 위치 (_r_, *c*)에서 1이 적혀 있는 칸에 도착하기 위한 최소 이동 횟수를 출력한다. 현재 위치 (_r_, *c*)에서 1이 적혀 있는 칸으로 이동할 수 없는 경우 -1을 출력한다.

<br/>

### 제한

- 0 ≤ *r*, *c* ≤ 4
- 학생의 현재 위치 (_r_, *c*)에는 0이 적혀 있다.
- 1이 적혀 있는 격자가 1개 주어진다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
0 0 1 0 0
0 0 -1 0 0
0 0 0 0 0
0 0 -1 0 0
0 0 0 -1 0
1 1

// 예제 출력 1
2
```

<br/>

### 📕 문제 포인트

1. 입력 값으로 전달 받은 데이터에서 시작 좌표 값을 읽어와 해당 좌표에서 시작하여 상하좌우 네 방향을 탐색한다.
   - 상하좌우 탐색하여 5\*5 범위를 벗어나거나 이동하려는 위치를 이미 방문했거나 이동하려는 위치 값이 -1이라면 이동할 수 없는 위치이기 때문에 건너 뛰어준다.
2. 이동이 가능한 위치라면 count 값을 1증가 시켜 이동 횟수를 누적해주고 queue에 새로 이동한 위치를 담아 이후 위치에서 네 방향을 다시 탐색한다.
3. 만약 도착하려는 지점에 도달했다면 즉시 현재까지의 count 값을 출력해준다.
4. 그게 아닌 경우 더 이상 이동할 위치가 없다고 판단되면 while문이 중료되어 -1을 반환한다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [R, C] = input.pop().split(" ").map(Number);
const arr = input.map((a) => a.split(" ").map(Number));

const nx = [-1, 0, 1, 0];
const ny = [0, 1, 0, -1];

const visited = Array.from({ length: 5 }, () =>
  Array.from({ length: 5 }, () => false)
);

const queue = [[R, C, 0]];
visited[R][C] = true;

while (queue.length > 0) {
  const [x, y, count] = queue.shift();

  if (arr[x][y] === 1) {
    console.log(count);
    return;
  }

  for (let k = 0; k < 4; k++) {
    const dx = x + nx[k];
    const dy = y + ny[k];

    if (dx < 0 || dy < 0 || dx > 4 || dy > 4) {
      continue;
    }
    if (visited[dx][dy]) {
      continue;
    }
    if (arr[dx][dy] === -1) {
      continue;
    }

    visited[dx][dy] = true;
    queue.push([dx, dy, count + 1]);
  }
}

console.log(-1);
```
