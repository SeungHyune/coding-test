# 2개 이하로 다른 비트

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/77885)

### 문제설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

- `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

| 수  | 비트         | 다른 비트의 개수 |
| --- | ------------ | ---------------- |
| 2   | `000...0010` |                  |
| 3   | `000...0011` | 1                |

- `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

| 수  | 비트         | 다른 비트의 개수 |
| --- | ------------ | ---------------- |
| 7   | `000...0111` |                  |
| 8   | `000...1000` | 4                |
| 9   | `000...1001` | 3                |
| 10  | `000...1010` | 3                |
| 11  | `000...1011` | 2                |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

<br/>

### 입출력 예

| numbers | result   |
| ------- | -------- |
| `[2,7]` | `[3,11]` |

<br/>

### 📕 문제 포인트

1. 각 숫자를 이진수 문자열로 변환합니다.
2. 이진수의 끝에서부터 `1`의 개수를 세어, `0`이 나오면 루프를 종료합니다.
3. `1`의 개수에 따라 비트를 변경하여 다음 숫자를 계산합니다.
4. 계산된 다음 숫자를 결과 배열에 추가합니다.

### 📝 문제 풀이

```js
function solution(numbers) {
  let answer = [];
  for (let i = 0; i < numbers.length; i++) {
    let binary = numbers[i].toString(2);
    let num = 0;
    for (let j = binary.length - 1; j >= 0; j--) {
      if (binary[j] === "0") {
        break;
      }
      if (binary[j] === "1") num++;
    }
    if (num === 0) num = 1;
    answer.push(numbers[i] + 2 ** (num - 1));
  }
  return answer;
}
```
