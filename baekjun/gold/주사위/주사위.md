# 주사위

---

[문제 링크](https://www.acmicpc.net/problem/1041)

### 문제설명

```
    +---+
    | D |
+---+---+---+---+
| E | A | B | F |
+---+---+---+---+
    | C |
    +---+

```

주사위는 위와 같이 생겼다. 주사위의 여섯 면에는 수가 쓰여 있다. 위의 전개도를 수가 밖으로 나오게 접는다.

A, B, C, D, E, F에 쓰여 있는 수가 주어진다.

지민이는 현재 동일한 주사위를 N3개 가지고 있다. 이 주사위를 적절히 회전시키고 쌓아서, N×N×N크기의 정육면체를 만들려고 한다. 이 정육면체는 탁자위에 있으므로, 5개의 면만 보인다.

N과 주사위에 쓰여 있는 수가 주어질 때, 보이는 5개의 면에 쓰여 있는 수의 합의 최솟값을 출력하는 프로그램을 작성하시오.

!https://www.acmicpc.net/JudgeOnline/upload/201007/qazwqszx.png

### 입력

첫째 줄에 N이 주어진다. 둘째 줄에 주사위에 쓰여 있는 수가 주어진다. 위의 그림에서 A, B, C, D, E, F에 쓰여 있는 수가 차례대로 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, 쓰여 있는 수는 50보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 문제의 정답을 출력한다.

### 예제

```jsx
// 예제 1
2
1 2 3 4 5 6

// 예제 출력 1
36

// 예제 2
3
1 2 3 4 5 6

// 예제 출력 2
69
```

### 📕 문제 포인트

1. 6면에 숫자가 적혀 있는 주사위를 통해 N _ N _ N의 정육면체를 만들어 각 면에 수를 합산 수가 최솟값이 되도록 만든 뒤 최솟값을 출력하라
2. N*N은 각 층의 주사위 개수이다. N은 N*N개의 주사위가 몇 층이 필요한 지 나타내준다.
3. N\*N 개의 주사위가 N 층 쌓이는 경우, 1층부터 N-1 층까지는 모서리(4개) 개가 주사위 2면의 숫자를 보이며 모서리를 제외한 측면은 하나의 면이 보이게 된다.
   - 이를 통해 모서리(4개) \* 서로 마주 보지 않는 주사위 2면의 최솟값를 통해 모서리 수를 구할 수 있다.
   - 측면의 경우 주사위에 적혀 있는 수중 가장 작은 수와 측면 개수( `(N-2) * 4` )를 곱한다.
   - 이후 두 수를 합산 후 N - 1을 곱한다. 그럼 1층부터 N - 1층의 주사위 면의 최솟값이 구해진다.
4. 마지막으로 가장 위층을 구하면 되는데 지금까지와 다른 점은 가장 위층은 지금까지 구한 것과 다르게 한 면이 더 보이게 된다.
   - 서로 마주 보지 않는 주사위 3면의 최솟값을 구한 뒤 \* 모서리 개수(4개)를 통해 위층 모서리 면의 수를 구한다.
   - 측면 개수( `(N-2) * 4` )는 위와 동일하게 구한다. 그 후 서로 마주 보지 않는 주사위 2면의 최솟값과 곱한다.
   - 그 후 내부 주사위 개수( `N * N - 4 - ((N-2) * 4)` )와 최솟값(주사위 면 중 가장 작은 수)과 곱해준다.
   - 모든 수를 더하면 위층의 주사위 면의 최솟값이 구해진다.
5. 마지막으로 위에서 구한 N-1개의 층의 수와 위층을 더하면 문제가 해결된다.

### 📝 문제 풀이

```js
// N은 정육면체의 층이다.
// N*N은 한 층의 주사위 개수이다.

// 1 ~ N - 1 층의 경우
// 각 층의 모서리 = 4(모서리 수) * 서로 마주 보지 않는 최솟값 (2개의 합)
// 측면에서 보이는 면의 수 = ((N - 2) * 4) * 최솟값 (1개의 합)

// 위에서 구한 값의 합을 * N - 1 곱해줍니다. (윗면에 다른 정육면체 층이 놓이므로 윗면은 보이지 않는다. 각 면을 감싼 부분을 제외한 안쪽 정육면체는 보이지 않음.)

// 마지막으로 젤 위층은 1면이 더 보이게 되며, 안쪽에 있는 내부 정육면체는 위 면 한곳이 보이게 됨.
// 각 층의 모서리 = 4(모서리 수) * 서로 마주 보지 않는 최솟값 (3개의 합)
// 측면에서 보이는 면의 수 = ((N - 2) * 4) * 서로 마주 보지 않는 최솟값 (2개의 합)
// 보이지 않는 정육면체 수 = 한 층의 주사위 수 - 각층의 모서리 수(4개) + 측면에서 보이는 면의 수
// 보이지 않는 정육면체 수 * 최솟값 (1개)

// 모두 더한 값을 출력해라

const fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const N = Number(input.shift()); // 정육면체 높이
const length = N * N; // 정육면체 한층의 주사위 수
const wall = (N - 2) * 4; // 정육면체 측면 (모서리를 제외한 측면)
const inWall = length - wall - 4; // 정육면체 내부 (측면 테두리를 제외한 내부)

const [dice] = input.map((a) => a.split(" ").map(Number));

const one = Math.min(...dice); // 가장 작은 수
let two = Number.MAX_SAFE_INTEGER; // 주사위 면이 마주 보지 않는 가장 작은 두 수의 합
let three = Number.MAX_SAFE_INTEGER; // 주사위 면이 마주 보지 않는 가장 작은 세 수의 합

// N이 1인 경우 가장 큰 수를 제외한 5면의 합을 구해야 함
if (N === 1) {
  const max = Math.max(...dice);
  const result = dice.reduce((prev, cur) => prev + cur, 0) - max;

  return console.log(result);
}

for (let i = 0; i < 6; i++) {
  for (let j = 0; j < 6; j++) {
    if (i === j || (i + 1 + j + 1) % 7 === 0) continue;

    two = Math.min(two, dice[i] + dice[j]);

    for (let k = 0; k < 6; k++) {
      if (
        i === k ||
        j === k ||
        (i + 1 + k + 1) % 7 === 0 ||
        (j + 1 + k + 1) % 7 === 0
      )
        continue;

      three = Math.min(three, dice[i] + dice[j] + dice[k]);
    }
  }
}

const firstFloor = (two * 4 + one * wall) * (N - 1);
const lastFloor = three * 4 + two * wall + one * inWall;

console.log(firstFloor + lastFloor);
```
