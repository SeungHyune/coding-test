# 마인크래프트

---

[문제 링크](https://www.acmicpc.net/problem/18111)

### 문제

팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.

목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.

lvalue는 세로 *N*, 가로 *M* 크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.

1. 좌표 (_i_, *j*)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.
2. 인벤토리에서 블록 하나를 꺼내어 좌표 (_i_, *j*)의 가장 위에 있는 블록 위에 놓는다.

1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.

단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는 *B*개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.

### 입력

첫째 줄에 *N, M*, *B*가 주어진다. (1 ≤ *M*, *N* ≤ 500, 0 ≤ *B* ≤ 6.4 × 107)

둘째 줄부터 *N*개의 줄에 각각 *M*개의 정수로 땅의 높이가 주어진다. (*i* + 2)번째 줄의 (*j* + 1)번째 수는 좌표 (_i_, *j*)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.

### 출력

첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.

### 예제 입력

```jsx
// 예제 입력 1
3 4 99
0 0 0 0
0 0 0 0
0 0 0 1

// 예제 출력 1
2 0
```

### 📕 문제 포인트

1. 주어진 높이 배열에서 최대 높이, 최소 높이를 계산합니다. (이 두 값은 높이를 조정할 때의 범위를 결정합니다.)
2. 주어진 높이 범위 내에서각 높이에 대한 작업을 수행합니다.
   - time 변수: 현재 높이로 맞추는데 소요되는 시간을 저장
   - b 변수: 남은 블록 수를 저장
3. 모든 칸을 순회하며 현재 칸의 높이가 목표 높이보다 낮으면 블록을 추가해야 하므로, 블록 수를 감소시키고 시간에 추가하는 데 소요되는 시간을 더합니다.
4. 반대로, 현재 칸의 높이가 목표 높이보다 높으면 블록을 제거해야 하므로, 블록 수를 증가시키고 두 배의 시간을 더합니다.
5. 모든 칸을 처리한 후, 남은 블록 수(b)가 0 이상인지 확인합니다.
6. 현재 높이(i)에서의 시간을 기록하고, 이전에 기록된 시간보다 짧거나 같으면 현재 높이와 시간을 갱신합니다.
7. 최소 시간과 해당 높이를 출력합니다.

### 📝 문제 풀이

```js
const fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [N, M, B] = input[0].split(" ").map(Number);
const arr = input.slice(1).map((v) => v.split(" ").map(Number));

function solution(N, M, B, max, min) {
  let answer = [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];

  for (let i = min; i <= max; i++) {
    let time = 0;
    let b = B;
    for (let n = 0; n < N; n++) {
      for (let m = 0; m < M; m++) {
        const sum = Math.abs(arr[n][m] - i);
        if (arr[n][m] < i) {
          b -= sum;
          time += sum;
        } else if (arr[n][m] > i) {
          b += sum;
          time += sum * 2;
        }
      }
    }

    if (b < 0) {
      continue;
    }
    if (answer[0] >= time) {
      answer = [time, i];
    }
  }

  return answer.join(" ");
}

const flatMap = arr.flatMap((v) => v);
const max = Math.max(...flatMap);
const min = Math.min(...flatMap);

console.log(solution(N, M, B, max, min));
```
