# **비밀번호**

[문제 링크](https://www.acmicpc.net/problem/2780)

### 문제

석원이는 자신의 현관문에 비밀번호 기계를 설치했다. 그 기계의 모양은 다음과 같다.

지나가던 석원이 친구 주희는 단순한 호기심에 저 비밀번호를 풀고 싶어한다. 이때 주희는 바닥에 떨어져 있는 힌트 종이를 줍게 된다. 이 종이에는 석원이가 비밀번호를 만들 때 사용했던 조건이 적혀 있다. 이제 주희는 이 조건을 가지고, 석원이 집의 가능한 비밀번호의 전체 개수를 알고 싶어 한다. 현재 컴퓨터를 사용할 수 없는 주희는 당신에게 이 문제를 부탁했다. 석원이의 힌트 종이는 다음과 같다.

![pw.png](https://github.com/user-attachments/assets/0af0ee50-eebf-4719-9867-0b03987a6469)

1. 비밀번호의 길이는 N이다.
2. 비밀번호는 위 그림에 나온 번호들을 눌러서 만든다.
3. 비밀번호에서 인접한 수는 실제 위 기계의 번호에서도 인접해야 한다.

(ex. 15 라는 비밀번호는 불가능하다. (1과 5는 인접하지 않는다. ) 하지만 1236이라는 비밀번호는 가능하다.)

<br/>

### 입력

첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 비밀번호의 길이 N이 주어진다.( 1 <= N <= 1,000 )

<br/>

### 출력

각각의 Test case에 대해서 조건을 만족하는 비밀번호의 개수를 출력하라. 단, 수가 매우 커질 수 있으므로 비밀번호의 개수를 1,234,567으로 나눈 나머지를 출력하라.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
3;
1;
2;
3;

// 예제 출력 1
10;
26;
74;
```

<br/>

### 📕 문제 포인트

1. `memo` 배열을 사용하여 각 자리수에 대한 경우의 수를 저장합니다. 초기 상태로 1자리 비밀번호에 대한 경우의 수를 설정합니다.
2. `dp(n)` 함수는 길이가 `n` 인 비밀번호의 경우의 수를 계산합니다.
   - `memo` 배열에 이밎 저장된 경우의 수가 있다면 이를 반환합니다.
3. 키패드에서 각 숫자에 대해 이동 가능한 이웃 키를 정의합니다.
   - 이를 위해 방향 배열 `dr` 과 `dc` 를 사용합니다.
   - 각 숫자(0~9)에 대해 가능한 이웃 키로부터의 경우의 수를 합산합니다.
4. 키패드의 경계를 넘어가는 경우 무시합니다.
   - 특정 규칙에 따라 0과 3에 대한 처리를 추가하여 경우의 수를 업데이트합니다.
5. `count(m)` 함수를 통해 계산된 경우의 수를 합산하여 반환합니다.
6. 각 테스트 케이스에 대해 `dp(N)`을 호출하여 얻은 결과를 `count 함수`로 합산한 후 결과를 반환합니다.

### 📝 문제 풀이

```js
const input = require("fs")
  .readFileSync(0, "utf-8")
  .toString()
  .trim()
  .split("\n")
  .map(Number);
const T = input[0];
const memo = [[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1]]];
const D = 1234567;
let answer = "";

function dp(n) {
  if (memo.length >= n) {
    return memo[n - 1];
  }

  const dr = [0, 1, 0, -1];
  const dc = [1, 0, -1, 0];
  const im = memo[n - 2] || dp(n - 1);
  const m = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0]];

  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      for (let i = 0; i < 4; i++) {
        const ir = r + dr[i];
        const ic = c + dc[i];

        if (ir < 0 || ir >= 3 || ic < 0 || ic >= 3) {
          continue;
        }

        m[r][c] = (m[r][c] + im[ir][ic]) % D;
      }
    }
  }

  m[2][0] = (m[2][0] + im[3][0]) % D;
  m[3][0] = (m[3][0] + im[2][0]) % D;
  memo[n - 1] = m;

  return m;
}

function count(m) {
  let sum = 0;

  for (let r = 0; r < 4; r++) {
    const row = m[r];

    for (let c of row) {
      sum = (sum + c) % D;
    }
  }

  return sum;
}

for (let t = 1; t <= T; t++) {
  const N = input[t];

  answer += `${count(dp(N))}\n`;
}

console.log(answer);
```
