# 좋은 구간

[문제 링크](https://www.acmicpc.net/problem/1059)

### 문제

정수 집합 S가 주어졌을때, 다음 조건을 만족하는 구간 [A, B]를 좋은 구간이라고 한다.

- A와 B는 양의 정수이고, A < B를 만족한다.
- A ≤ x ≤ B를 만족하는 모든 정수 x가 집합 S에 속하지 않는다.

집합 S와 n이 주어졌을 때, n을 포함하는 좋은 구간의 개수를 구해보자.

<br/>

### 입력

첫째 줄에 집합 S의 크기 L이 주어진다. 둘째 줄에는 집합에 포함된 정수가 주어진다. 셋째 줄에는 n이 주어진다.

<br/>

### 출력

첫째 줄에 n을 포함하는 좋은 구간의 개수를 출력한다.

<br/>

### 제한

- 1 ≤ L ≤ 50
- 집합 S에는 중복되는 정수가 없다.
- 집합 S에 포함된 모든 정수는 1보다 크거나 같고, 1,000보다 작거나 같다.
- 1 ≤ n ≤ (집합 S에서 가장 큰 정수)

<br/>

### 예제 입력

```jsx
// 예제 입력 1
4
1 7 14 10
2

// 예제 출력 1
4
```

<br/>

### 📕 문제 포인트

1. 좋은 구간을 이해하는 것이 가장 중요하며, 집합의 범위 보다 작은 N 값도 나올 수 있습니다.
   - 집합 : [4, 5, 6] / N : 2
   - ⇒ [1, 3], [1, 2], [2, 3]
2. 좋은 구간을 찾기 위해 집합 배열을 오름차순으로 정렬한 후 집합[0] 보다 작은 N 값의 좋은 구간을 찾기 위해 초기 배열 맨 앞에 `0` 값을 추가했습니다.
   - 이때, 집합의 수 S에도 `+1` 해주었습니다.
3. 이제 [left, right] 포인트를 [0, 1]에서 시작하여 `left < right && right < S` 작을 때까지 반복합니다.
   - arr[left] + 1 값, arr[right] - 1 값의 범위에 N이 속한다면 내부 반복문을 시작합니다.
   - 아니라면 해당 범위는 좋은 구간이 아니므로 패스합니다.
4. `l <= N && N <= r` 조건을 통해 좋은 구간이 있는지 검사하고 내부 `while 문` 을 통해 `l < r && l <= N && N <= r` 한 번 더 조건에 맞는 경우 반복하도록 합니다.
   - 매 반복마다 r 값을 1씩 감소시켜 줍니다.
   - 매 반복마다 좋은 구간이기 때문에 answer를 1씩 증가시켜 줍니다.
5. 내부 while 문 조건이 끝나면 이제 다음 구간을 검사하기 위해 `l` 값을 1 증가시켜주고, `r` 값은 `arr[right] - 1` 값으로 초기화해줍니다.
6. 현재 범위의 구간을 다 구한 뒤 `left, right` 값을 1씩 증가시키고 다음 구간을 검사합니다.

### 📝 문제 풀이

```js
// 좋은 구간이란?
// 좋은 구간이란
// 두 정수 A, B가 주어졌을 때
// 찾으려는 값 N를 A <= N <= B로 포함해야한다.
// 하지만 집합의 수에는 포함되면 안된다.

// ex) 집합 [1, 4, 5, 10, 20] 이고 N = 3이라면
// [2, 3] 만 가능하다. N이 집합에 없는 구간 부터 시작할 수 있으며, N을 정수 A, B가 포함하거나
// A, B 범위 내에 N이 존재해야 한다.

const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const S = Number(input.shift()) + 1;
const N = Number(input.pop());

const arr = [0, ...input[0].split(" ").map(Number)];
arr.sort((a, b) => a - b);

let [left, right] = [0, 1];

let answer = 0;

while (left < right && right < S) {
  const start = arr[left];
  const end = arr[right];

  let [l, r] = [start + 1, end - 1];
  // l, r 구간에 대한 조건 확인 필요
  // 2, 6
  // [2,3], [2,4], [2,5], [2,6]
  while (l <= N && N <= r) {
    while (l < r && l <= N && N <= r) {
      answer++;
      r--;
    }

    l++;
    r = end - 1;
  }

  left++;
  right++;
}

console.log(answer);
```
