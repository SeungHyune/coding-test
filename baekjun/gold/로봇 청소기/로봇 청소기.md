# **로봇 청소기**

[문제 링크](https://www.acmicpc.net/problem/14503)

### 문제설명

로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.

로봇 청소기가 있는 방은 𝑁×𝑀 크기의 직사각형으로 나타낼 수 있으며, 1×1 크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 방의 각 칸은 좌표 (𝑟,𝑐)로 나타낼 수 있고, 가장 북쪽 줄의 가장 서쪽 칸의 좌표가 (0,0) 가장 남쪽 줄의 가장 동쪽 칸의 좌표가 (𝑁−1,𝑀−1)이다. 즉, 좌표 (𝑟,𝑐)는 북쪽에서 (𝑟+1)번째에 있는 줄의 서쪽에서 (𝑐+1)번째 칸을 가리킨다. 처음에 빈 칸은 전부 청소되지 않은 상태이다.

로봇 청소기는 다음과 같이 작동한다.

1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.
2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우,
   1. 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.
   2. 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.
3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우,
   1. 반시계 방향으로 90∘ 회전한다.
   2. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.
   3. 1번으로 돌아간다.

!https://www.acmicpc.net/JudgeOnline/upload/201007/qazwqszx.png

<br/>

### 입력

첫째 줄에 방의 크기 𝑁과 𝑀이 입력된다. (3≤𝑁,𝑀≤50) 둘째 줄에 처음에 로봇 청소기가 있는 칸의 좌표 (𝑟,𝑐)와 처음에 로봇 청소기가 바라보는 방향 𝑑가 입력된다. 𝑑가 0인 경우 북쪽, 1인 경우 동쪽, 2인 경우 남쪽, 3인 경우 서쪽을 바라보고 있는 것이다.

셋째 줄부터 𝑁개의 줄에 각 장소의 상태를 나타내는 𝑁×𝑀개의 값이 한 줄에 𝑀개씩 입력된다. 𝑖번째 줄의 𝑗번째 값은 칸 (𝑖,𝑗)의 상태를 나타내며, 이 값이 0인 경우 (𝑖,𝑗)가 청소되지 않은 빈 칸이고, 1인 경우 (𝑖,𝑗)에 벽이 있는 것이다. 방의 가장 북쪽, 가장 남쪽, 가장 서쪽, 가장 동쪽 줄 중 하나 이상에 위치한 모든 칸에는 벽이 있다. 로봇 청소기가 있는 칸은 항상 빈 칸이다.

<br/>

### 출력

로봇 청소기가 작동을 시작한 후 작동을 멈출 때까지 청소하는 칸의 개수를 출력한다.

<br/>

### 예제

```jsx
// 예제 1
3 3
1 1 0
1 1 1
1 0 1
1 1 1

// 예제 출력 1
1
```

<br/>

### 📕 문제 포인트

1. 초기 로봇 청소기의 위치와 로봇 청소기가 가리키는 방향을 저장합니다.
2. 이후 해당 위치에서 동, 서, 남, 북 네 방향을 탐색하여 청소할 수 있는 빈칸이 있는지 탐색합니다. 만약 갈 수 있다면 로봇 청소기가 가리키는 방향을 반 시계 방향으로 90도 변경합니다. 그 후 청소리가 가리키는 방향으로 한 칸 앞으로 이동합니다. 만약 해당 지점이 벽이거나 이미 방문한 지점이라면 이동하지 않고 다시 반 시계 방향으로 90도 변경한 뒤 한 칸 앞으로 이동하는 것을 반복합니다.
3. 그 후 갈 수 있는 빈칸으로 이동합니다.
4. 만약 동, 서, 남, 북 네 방향을 탐색하여 청소할 수 있는 빈칸이 없는 경우 현재 청소기가 가리키는 방향을 유지한 채로 한 칸 후진합니다. 만약 후진한 곳이 벽이거나 방 범위를 벗어난 경우 청소를 즉시 종료하고 현재까지 청소한 방을 출력합니다.
5. 위 과정을 로봇 청소기가 청소를 종료할 때까지 반복합니다.
6. 문제 포인트는 `0 -북`, `1 - 동`, `2 - 남`, `서 - 3`로 방향으로 이동하는 것을 미리 배열에 담아두는 것과 청소기 방향을 전역 변수로 저장해서 관리한다는 것이다. 반 시계 방향으로 90도 회전하는 경우 현재 청소기 방향에서 - 1 하면 된다. 이때 만약 청소기 방향이 -1이 되면 이때 3으로 변경해 주면 된다.
   - `const dx = [-1,0,1,0]` - 북동남서
   - `const dy = [0,1,0,-1]` - 북동남서
   - 현재 방향에서 앞으로 이동하는 경우 `x + dx[d]`, `y + dy[d]`
   - 현재 방향에서 뒤로 후진하는 경우 `x - dx[d]`, `y - dy[d]`

### 📝 문제 풀이

```js
const fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const dx = [-1, 0, 1, 0];
const dy = [0, 1, 0, -1];

let [N, M] = input.shift().split(" ").map(Number);
let [x, y, d] = input.shift().split(" ").map(Number);
let arr = input.map((a) => a.split(" ").map(Number));

let cleaning = 0;

const queue = [[x, y, d]];
while (queue.length > 0) {
  let [x, y, d] = queue.shift();

  if (arr[x][y] === 0) {
    // 빈 칸
    cleaning++;
    arr[x][y] = 2;
  }

  let check = 0;

  for (let k = 0; k < 4; k++) {
    const nx = x + dx[k];
    const ny = y + dy[k];

    if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;

    if (arr[nx][ny] === 0) {
      check++;
    }
  }

  if (check === 0) {
    // 주변 4칸 중 빈 칸이 없는 경우
    const nx = x - dx[d];
    const ny = y - dy[d];

    if (arr[nx][ny] === 1 || nx < 0 || ny < 0 || nx >= N || ny >= M) break;
    else {
      queue.push([nx, ny, d]);
    }
  }

  let i = 4;
  while (i-- > 0) {
    // 주변 4칸 중 빈 칸이 있는 경우
    d -= 1;
    if (d === -1) d = 3;

    const nx = x + dx[d];
    const ny = y + dy[d];

    if (arr[nx][ny] === 0) {
      queue.push([nx, ny, d]);
      break;
    }
  }
}

console.log(cleaning);
```
