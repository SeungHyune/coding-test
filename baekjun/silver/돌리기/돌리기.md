# 돌리기

[문제 링크](https://www.acmicpc.net/problem/1682)

### 문제

백준씨는 백준 큐브을 만들어 성공하고 난 뒤, 그것을 2차원 형식으로 바꾼 매직 스퀘어를 고안했다.

이것은 아래 그림과 같이 크기가 같은 여덟 개의 정사각형으로 되어 있다

![](https://www.acmicpc.net/JudgeOnline/upload/201005/dol.PNG)

이번 문제에서 우리는 각각의 정사각형 면이 서로 다른 색으로 칠해진 매직 스퀘어를 다룬다. 각 색깔은 1부터 시작하는 8개의 자연수로 표현된다. 한편, 스퀘어의 상태를 나타내는 수열이 있는데, 이는 여덟 개의 숫자로 이루어지며 좌측 상단부터 시작해서 시계 방향으로 수열의 수를 차례대로 채워나간다. 그러므로, 매직 스퀘어의 처음 상태를 이 수열로 나타내면 (1, 2, 3, 4, 5, 6, 7, 8)이 된다. 이를 특별한 경우로, 매직 스퀘어의 처음 상태라고 규정하겠다. 매직 스퀘어에는 네 가지 변환을 가할 수 있다. 이를 차례대로 A, B, C, D로 구분한다. 방법은 다음과 같다.

- A: 윗줄과 아랫줄에 있는 수 4개를 모두 바꾼다.
- B: 두 줄에 있는 수를 오른쪽으로 한 칸씩 옮기고, 맨 오른쪽에 있던 수를 맨 왼쪽으로 옮긴다.
- C: 가운데에 있는 네 정사각형의 수를 반 시계 방향으로 한 번 돌린다.
- D: 1번과 5번을 바꾼다. (1번과 5번이라는 것은 위치를 말함. 1,5번 위치는 위의 표의 숫자의 위치와 같음)

매직 스퀘어의 상태가 어떻든 위의 네 가지 변환을 시킬 수 있다.

이번 문제는 초기 상태에 있는 매직 스퀘어에 A, B, C, D 변환을 어느 횟수만큼 하여 지정한 상태의 매직 스퀘어를 만드는 최소의 동작 방법을 계산하는 프로그램을 작성하는 것이다. 참고로 안되는 경우는 없음.

<br/>

### 입력

첫째 줄에 매직 스퀘어의 숫자가 입력이 되며 순서는 위에서 말한 수열의 순서이다.

<br/>

### 출력

첫 줄에 A, B, C, D의 총 변환 횟수 L이 들어가야 한다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
6 4 2 8 1 3 5 7

// 예제 출력 1
5
```

<br/>

### 📕 문제 포인트

1. 초기 큐브 생태는 `[1,2,3,4,5,6,7,8]` 수열이며, 해당 수열을 그림으로 나타내면

   ```jsx
   1 2 3 4
   8 7 6 5
   ```

   상태가 된다.

2. 이때 A, B, C, D 타입으로 변환하며 `targetSquare` 를 찾으면 문제를 해결할 수 있다.
3. 변환할 수 있는 A, B, C, D 타입을 `square_types` 에 저장한다.

   - index를 기준으로 초깃값 [0,1,2,3,4,5,6,7]를 기준으로 변환한 값을 저장한다.

     ```jsx
     // A타입 변환
     7 6 5 4
     0 1 2 3
     ```

     A타입 최종 변환 = [7, 6, 5, 4, 3, 2, 1, 0]

     ```jsx
     // B타입 변환
     3 0 1 2
     4 7 6 5

     ```

     B타입 최종 변환 = [3, 0, 1, 2, 5, 6, 7, 4]

     ```jsx
     // C타입 변환
     0 2 5 3
     7 1 6 4
     ```

     C타입 최종 변환 = [0, 2, 5, 3, 4, 6, 1, 7]

     ```jsx
     // D타입 변환
     4 1 2 3
     7 6 5 0
     ```

     D타입 최종 변환 = [4, 1, 2, 3, 0, 5, 6, 7]

4. 미리 변환 수열을 `square_types` 에 저장한 후 BFS 탐색을 시작한다.
   - 이때, 중복 값을 피하기 위해 `new Set` 으로 `set` 변수를 만들어 기존에 생성한 큐브는 저장하고 이미 만든 큐브 동일한 큐브가 있는 경우는 탐색을 종료시킨다.
5. 탐색 시 `target_square` 값과 동일한 값을 찾았다면 즉시 `convert` 를 반환하여 종료한다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split(" ");

const start_square = "12345678";
const square_types = [
  [7, 6, 5, 4, 3, 2, 1, 0], // A 변환
  [3, 0, 1, 2, 5, 6, 7, 4], // B 변환
  [0, 2, 5, 3, 4, 6, 1, 7], // C 변환
  [4, 1, 2, 3, 0, 5, 6, 7], // D 변환
];

let target_square = "";

for (let i = 0; i < 8; i++) {
  target_square += input[i];
}

const queue = [[start_square, 0]];
const set = new Set();
set.add(start_square);

while (queue.length > 0) {
  const [square, convert] = queue.shift();

  if (target_square === square) {
    console.log(convert);
    return;
  }

  for (let i = 0; i < 4; i++) {
    const nextSquare = square_types[i].map((j) => square[j]).join("");

    if (set.has(nextSquare)) continue;

    set.add(nextSquare);
    queue.push([nextSquare, convert + 1]);
  }
}
```
