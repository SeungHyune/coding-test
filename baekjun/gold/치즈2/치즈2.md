# 치즈2

---

[문제 링크](https://www.acmicpc.net/problem/17141)

### 문제설명

인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 승원이는 연구소의 특정 위치에 바이러스 M개를 놓을 것이고, 승원이의 신호와 동시에 바이러스는 퍼지게 된다.

연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.

일부 빈 칸은 바이러스를 놓을 수 있는 칸이다. 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다.

```
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2
```

M = 3이고, 바이러스를 아래와 같이 놓은 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 바이러스를 놓은 위치는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.

```
6 6 5 4 - - 2
5 6 - 3 - 0 1
4 - - 2 - 1 2
3 - 2 1 2 2 3
2 2 1 0 1 - -
1 - 2 1 2 3 4
0 - 3 2 3 4 5
```

시간이 최소가 되는 방법은 아래와 같고, 5초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.

```
0 1 2 3 - - 2
1 2 - 3 - 0 1
2 - - 2 - 1 2
3 - 2 1 2 2 3
3 2 1 0 1 - -
4 - 2 1 2 3 4
5 - 3 2 3 4 5
```

연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.

!https://www.acmicpc.net/JudgeOnline/upload/201007/qazwqszx.png

### 입력

첫째 줄에 연구소의 크기 N(5 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.

둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.

### 출력

연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.

### 예제

```jsx
// 예제 1
7 3
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2

// 예제 출력 1
5
```

### 📕 문제 포인트

1. 이 문제는 치즈가 모두 녹아 없어지는 시간을 구하는 문제이다. 그렇기 때문에 가장 먼저 치즈가 몇 개인지 파악하는 것이 좋다고 생각했다.
2. 이후 치즈가 0이 될 때까지 while 문을 통해 계속해서 반복해 주었다.
3. 치즈는 공기를 두 곳 닿으면 한 시간 후에 녹아 없어진다. 이때, 내부 공기는 상관이 없고 외부 공기를 닿는 것에만 영향이 있다.
4. 치즈가 놓여 있는 장소의 맨 끝 가장 자리는 항상 치즈가 놓이지 않는다. 이를 통해 매번 `[0,0]`의 위치 공기에서 시작할 수 있다. 공기가 치즈에 닿으면 해당 위치의 치즈에 +1 증가시켜준다.
5. 이후 같은 방향으로 이동하여 치즈에 도달할 수 있기 때문에 N\*M 크기의 동일한 배열을 만들어 이미 방문한 경우 방문하지 못하도록 체크한다. 이렇게 되면 만약 치즈가 3 이상이 되는 경우라면 다른 방향으로 두 번 이상의 공기가 통했다는 소리가 된다.
6. 이를 활용해 한 번의 순회에 마다 1시간씩 증가하고 이때 치즈가 3 이상이 된 곳을 찾아 미리 파악해 둔 치즈의 개수를 1감소 시키고 해당 위치에 있는 치즈를 0(빈칸)으로 변경해 준다. 또 공기를 한 번만 통한 치즈는 다시 1로 변경해 주고 치즈가 모두 없어질 때까지 반복하면 치즈가 모두 없어질 때 걸리는 시간을 구할 수 있다.

### 📝 문제 풀이

```js
// N은 세로 격자의 수, M은 가로 격자의 수
// 치즈는 바깥 공기와 통하는 방향이 2번 이상 있는 경우 이 치즈는 한시간만에 녹아 없어져 버린다.
// 내부 공간의 경우 외부 공기와 접촉하지 않는 것으로 가정한다.

// 모눈종이의 맨 가장자리에는 치즈가 놓이지 않는 것으로 가정한다.
// 입력으로 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성하시오.

// 치즈가 있는 부분 - 1 / 치즈가 없는 부분 - 0

const fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [[N, M], ...arr] = input.map((a) => a.split(" ").map(Number));

const nx = [-1, 0, 1, 0];
const ny = [0, 1, 0, -1];

let result = 0;
let cheese = 0;

for (let i = 0; i < N; i++) {
  for (let j = 0; j < M; j++) {
    if (arr[i][j] === 1) {
      cheese++;
    }
  }
}

while (cheese > 0) {
  const visited = Array.from({ length: N }, () =>
    Array.from({ length: M }, () => false)
  );
  visited[0][0] = true;

  const queue = [[0, 0]];

  let index = 0;
  while (queue.length > index) {
    const [x, y] = queue[index++];

    for (let k = 0; k < 4; k++) {
      const dx = x + nx[k];
      const dy = y + ny[k];

      if (dx < 0 || dy < 0 || dx >= N || dy >= M) continue;
      if (visited[dx][dy]) continue;
      if (arr[dx][dy] >= 1) {
        arr[dx][dy]++;
        continue;
      }

      visited[dx][dy] = true;
      queue.push([dx, dy]);
    }
  }

  for (let i = 0; i < N; i++) {
    for (let j = 0; j < M; j++) {
      if (arr[i][j] === 0) continue;

      let flag = false;

      if (arr[i][j] >= 3) {
        arr[i][j] = 0;
        flag = true;
        cheese--;
      }

      if (flag === false) {
        arr[i][j] = 1;
      }
    }
  }

  result++;
}

console.log(result);
```
