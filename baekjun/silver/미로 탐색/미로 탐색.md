# 미로 탐색

[문제 링크](https://www.acmicpc.net/problem/2178)

### 문제설명

N×M크기의 배열로 표현되는 미로가 있다.

| 1   | 0   | 1   | 1   | 1   | 1   |
| --- | --- | --- | --- | --- | --- |
| 1   | 0   | 1   | 0   | 1   | 0   |
| 1   | 0   | 1   | 0   | 1   | 1   |
| 1   | 1   | 1   | 0   | 1   | 1   |

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

<br/>

### 입력

첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 **붙어서** 입력으로 주어진다.

<br/>

### 출력

첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

<br/>

### 예제 입력

```jsx
// 예제 입력1
4 6
101111
101010
101011
111011

// 예제 출력1
15
```

<br/>

### 📕 문제 포인트

1. 시작점은 좌측 상단인 배열의 `[0,0]`에서 항상 시작하며 도착점은 `[N-1,M-1]` 지점이다. 이때, 입력으로 들어온 배열에서 인접한 경로로 이동할 수 있는 경우는 1로 적혀 있는 곳만 가능하다. 0이 적혀 있는 곳으로는 움직일 수 없다.
2. 상하좌우로 이동할 수 있기 때문에 `nx` , `ny`라는 배열을 만들어 현재 위치(인덱스)에서 상하좌우를 탐색하여 이동할 수 있는 경우 이동할 수 있도록 했다.
3. 먼저 `N * M` 크기의 visited 배열을 초깃값 `Infinity` 로 설정하여 만든다.
   - `Infinity` 로 설정한 이유는 시작점(0,0)에서 도착점(N-1,M-1)로 이동할 수 있는 가장 짧은 경로를 찾아야 하기 때문이다.
4. 다음 시작점 `[0,0]` 을 `queue` 배열에 담고 `BFS` 순회를 시작한다.
5. 이때, 이동할 수 없는 경우에는 무시하고 인접한 경로로 이동할 수 있는 경우 `visited` 에 현재까지 이동한 거리를 갱신해 주고 `queue` 에 새로 이동하려는 좌표를 추가해 준다.
   - 이동할 수 없는 경우는 인접한 `dx, dy` 좌표가 배열의 범위를 벗어난 경우, 이동하려는 경로가 0인 경우, 이미 방문한 위치면서 현재 위치에서 가는 것보다 더 빠른 경로로 도착한 경우
   - 가장 핵심은 이미 방문한 위치보다 빠른 경로만 인접한 경로로 이동하는 것이다. (같은 경로에도 이동을 하지 않는다.)
6. 모든 순회를 마치고 도착점(N-1, M-1)을 출력하면 최소한의 이동거리로 도착점에 도착한 거리를 알 수 있다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [N, M] = input.shift().split(" ").map(Number);
const arr = input.map((a) => a.split("").map(Number));

const nx = [-1, 0, 1, 0];
const ny = [0, 1, 0, -1];

const visited = Array.from({ length: N }, () =>
  Array.from({ length: M }, () => Infinity)
);
visited[0][0] = 1;

const queue = [[0, 0]];

while (queue.length > 0) {
  const [x, y] = queue.shift();

  for (let k = 0; k < 4; k++) {
    const dx = x + nx[k];
    const dy = y + ny[k];

    if (dx < 0 || dx >= N || dy < 0 || dy >= M) continue;

    if (arr[dx][dy] === 0) continue;

    if (visited[dx][dy] <= visited[x][y] + 1) continue;

    visited[dx][dy] = visited[x][y] + 1;
    queue.push([dx, dy]);
  }
}

console.log(visited[N - 1][M - 1]);
```
