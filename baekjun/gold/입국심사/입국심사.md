# 입국심사

[문제 링크](https://www.acmicpc.net/problem/3079)

### 문제

상근이와 친구들은 오스트레일리아로 여행을 떠났다. 상근이와 친구들은 총 M명이고, 지금 공항에서 한 줄로 서서 입국심사를 기다리고 있다. 입국심사대는 총 N개가 있다. 각 입국심사관이 심사를 하는데 걸리는 시간은 사람마다 모두 다르다. k번 심사대에 앉아있는 심사관이 한 명을 심사를 하는데 드는 시간은 Tk이다.

가장 처음에 모든 심사대는 비어있고, 심사를 할 준비를 모두 끝냈다. 상근이와 친구들은 비행기 하나를 전세내고 놀러갔기 때문에, 지금 심사를 기다리고 있는 사람은 모두 상근이와 친구들이다. 한 심사대에서는 한 번에 한 사람만 심사를 할 수 있다. 가장 앞에 서 있는 사람은 비어있는 심사대가 보이면 거기로 가서 심사를 받을 수 있다. 하지만 항상 이동을 해야 하는 것은 아니다. 더 빠른 심사대의 심사가 끝나길 기다린 다음에 그 곳으로 가서 심사를 받아도 된다.

상근이와 친구들은 모두 컴퓨터 공학과 학생이기 때문에, 어떻게 심사를 받으면 모든 사람이 심사를 받는데 걸리는 시간이 최소가 될지 궁금해졌다.

예를 들어, 두 심사대가 있고, 심사를 하는데 걸리는 시간이 각각 7초와 10초라고 하자. 줄에 서 있는 사람이 6명이라면, 가장 첫 두 사람은 즉시 심사를 받으러 가게 된다. 7초가 되었을 때, 첫 번째 심사대는 비어있게 되고, 세 번째 사람이 그곳으로 이동해서 심사를 받으면 된다. 10초가 되는 순간, 네 번째 사람이 이곳으로 이동해서 심사를 받으면 되고, 14초가 되었을 때는 다섯 번째 사람이 첫 번째 심사대로 이동해서 심사를 받으면 된다. 20초가 되었을 때, 두 번째 심사대가 비어있게 된다. 하지만, 여섯 번째 사람이 그 곳으로 이동하지 않고, 1초를 더 기다린 다음에 첫 번째 심사대로 이동해서 심사를 받으면, 모든 사람이 심사를 받는데 걸리는 시간이 28초가 된다. 만약, 마지막 사람이 1초를 더 기다리지않고, 첫 번째 심사대로 이동하지 않았다면, 모든 사람이 심사를 받는데 걸리는 시간이 30초가 되게 된다.

상근이와 친구들이 심사를 받는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.

<br/>

### 입력

첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ M ≤ 1,000,000,000)

다음 N개 줄에는 각 심사대에서 심사를 하는데 걸리는 시간인 Tk가 주어진다. (1 ≤ Tk ≤ 109)

<br/>

### 출력

첫째 줄에 상근이와 친구들이 심사를 마치는데 걸리는 시간의 최솟값을 출력한다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
7 10
3
8
3
6
9
2
4

// 예제 출력 1
8
```

<br/>

### 📕 문제 포인트

1. 모든 친구들이 입국 심사를 통과할 수 있는 최소 시간을 구해야 하는 문제입니다.
2. 이 문제는 이분 탐색 알고리즘을 활용하여, 임의의 입국 심사 시간을 설정한 후 해당 시간으로 통과할 수 있다면 더 작은 심시 시간으로 통과할 수 있는지 검사하도록 하고, 통과할 수 없다면 더 긴 시간으로 통과할 수 있기 때문에 더 큰 시간으로 검사하도록 하는 로직을 작성하여 풀이하면 되는 문제입니다.
3. 이 문제는 node.js로 풀기에는 정수 범위를 초과하여 `BigInt` 를 활용하여 문제를 풀이해야 합니다.
   - 이 부분이 가장 어려웠던 문제입니다.
   - `BigInt` 타입은 `Number` 타입과 계산이 되지 않기 때문에 계산하는 값을 모두 `BigInt` 로 변환하여 계산을 해줘야 합니다.
4. 이후 결괏값을 최종 출력할 땐 `String`으로 변환하여 출력해 줍니다.
5. `[start,end]` 범위를 `[1, 입국 심사 시간이 가장 긴 장소 * M]`으로 설정한 후 `mid` 값을 통해 시간을 구합니다.
6. mid 값을 통해 입국 심사 시간으로 나누어 mid 시간으로 총 심사할 수 있는 사람의 수를 파악합니다.
7. 심사할 수 있는 사람의 수가 M보다 같거나 많다면 더 작은 시간으로 계속해서 검사합니다.
8. 반대로 M보다 작다면 해당 시간으로는 심사가 불가능하므로 더 큰 시간으로 계속해서 검사합니다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

let [N, M] = input.shift().split(" ").map(Number);
const arr = input.map(Number);
arr.sort((a, b) => a - b);

let max = BigInt(M) * BigInt(arr[N - 1]);
let [start, end] = [BigInt(1), max];
let answer;

while (start <= end) {
  const mid = BigInt((start + end) / 2n);

  let audit = BigInt(0);
  for (const time of arr) {
    audit += mid / BigInt(time);

    if (audit > M) break;
  }

  if (audit >= M) {
    answer = mid;
    end = mid - 1n;
  } else {
    start = mid + 1n;
  }
}

console.log(String(answer));
```
