# **게으른 백곰**

[문제 링크](https://www.acmicpc.net/problem/10025)

### 문제

더운 여름날 동물원의 백곰 앨버트는 너무 더워서 꼼짝도 하기 싫다. 다행히도 사육사들이 앨버트의 더위를 식히기 위해 얼음이 담긴 양동이들을 가져다 주었다. 앨버트가 가장 적은 거리만 움직이고도 최대한 많은 얼음으로 더위를 식힐 수 있도록 도와주자.

우리 안은 1차원 배열로 생각하며, 총 N(1 ≤ N ≤ 100000)개의 얼음 양동이들이 xi(0 ≤ xi ≤ 1,000,000)좌표마다 놓여 있고 각 양동이 안에는 gi(1 ≤ gi ≤ 10,000)씩의 얼음이 들어 있다. 일단 앨버트가 자리를 잡으면 그로부터 좌우로 K(1 ≤ K ≤ 2,000,000) 만큼 떨어진 양동이까지 닿을 수 있다. 앨버트는 양동이가 놓여 있는 자리에도 자리잡을 수 있다. 모든 얼음 양동이의 위치는 다르다.

앨버트가 최적의 자리를 골랐을 때 얼음의 합을 구하시오. 즉, 얼음들의 합의 최댓값을 구해야 한다.

<br/>

### 입력

첫 줄에 정수 N과 K가 들어온다. 둘째 줄부터 N째 줄까지, 공백을 사이에 두고 각 양동이의 얼음의 양을 나타내는 gi와 양동이의 좌표를 나타내는 xi가 주어진다.

<br/>

### 출력

앨버트가 택한 최적 위치로부터 K만큼 떨어진 거리 내에 있는 얼음들의 합(최댓값)을 출력한다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
4 3
4 7
10 15
2 2
5 1

// 예제 출력 1
11
```

<br/>

### 📕 문제 포인트

1. 앨버트가 택한 위치로부터 +- `K` 만큼 떨어진 지점의 얼음이 최대가 되는 숫자를 찾는 문제이다.
2. 먼저 `[얼음의 개수, 얼음의 위치]`가 담긴 배열을 오름차순으로 정렬한다.
   - 만약 배열의 수 N이 1인 경우에는 얼음 양동이가 한 개이기 때문에 즉시 출력 후 return 하여 함수를 종료시켜준다.
3. 이후 `left, right` 지점을 각각 `[0, 1]`로 위치 시킨 후 투 포인트 탐색을 시작한다.
4. 특정 위치에서 **+- `K` 만큼의 범위를 포함**할 수 있으므로 `K * 2`를 `maximum`변수에 저장한다.
5. **right 지점이 left 지점보다 항상 앞서 있기 때문에** `right < N`이라는 조건을 통해 while 문을 반복해 준다.
6. while 문 내부에서는 `arr[right][1] - arr[left][1]`을 계산하여 right, left 지점의 위치가 **`maximum` 보다 작은 경우**에는 다음 포인트의 얼음을 구할 수 있다.
   - 이때 현재 **right 지점의 얼음을 ice 변수에 더해준 후** 다음 얼음 위치를 구하기 위해 **right를 1 증가** 시켜준다.
7. 만약 `arr[right][1] - arr[left][1]`을 계산하여 위치가 **maximum 보다 큰 경우**에는 현재 지점의 얼음을 합칠 수 없기 때문에, **현재 left의 얼음을 ice에서 빼주고** left를 1 증가시켜줘서 다음 계산을 이어간다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [[N, K], ...arr] = input.map((a) => a.split(" ").map(Number));

// 얼음 양동이가 하나 밖에 없는 경우
if (N === 1) {
  console.log(arr[0][0]);
  return;
}

arr.sort((a, b) => a[1] - b[1]);

let [left, right] = [0, 1];
let maximum = K * 2;

let ice = arr[left][0];

let answer = arr[left][0];

while (right < N) {
  if (arr[right][1] - arr[left][1] <= maximum) {
    // right를 더 늘려서 더 많은 얼음의 합을 구할 수 있음
    ice += arr[right][0];
    right++;
  } else {
    // right의 값을 고정한채 left 값을 늘려야함
    // 현재 값으로는 얼음의 합을 구할 수 없음
    ice -= arr[left][0];
    left++;
  }

  answer = Math.max(answer, ice);
}

console.log(answer);
```
