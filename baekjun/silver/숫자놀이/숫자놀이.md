# 숫자놀이

[문제 링크](https://www.acmicpc.net/problem/1679)

### 문제

홀순이(holsoon)와 짝순이(jjaksoon) 둘이서 숫자 게임을 한다. 예를 들어, 정수 1과 3이 주어지고, 이 둘을 통틀어 5번까지 마음대로 사용하여 그 합을 구하여 1,2,3,…을 만드는 놀이다. 이 경우 먼저 홀순이가 1 하나만을 사용하여 1을 만든다. 짝순이는 1+1로 1을 두 번 사용하여 2를 만들고, 다시 홀순이는 3을 만들어야하는데 1+1+1로 1을 세 번 사용하거나 3을 한 번 사용하여 3을 만든다. 짝순이는 1+1+1+1, 1+3으로 4를 만든다. 서로 번갈아서 상대방의 수보다 1이 큰 수를 만들어야 한다. 단, 1과 3을 통틀어 최대 5번 사용한다. 이런 식으로 진행하면 13까지는 만들 수 있지만 14를 만들지 못하게 되므로 짝순이가 졌다.

숫자 게임에서 사용하는 정수 N개와 최대 사용 횟수 K가 주어질 때, 누가 어느 수에서 이기는지를 판별하는 프로그램을 작성해보자. 사용하는 정수에는 반드시 1이 포함된다. 그렇지 않으면 홀순이가 1을 만들지 못하므로 무조건 지게 된다. 1이 꼭 있으니 상대방이 만든 방법에 1만 한 번 더 쓰면 된다고 생각하기 쉽지만, 최대 사용 횟수가 정해져 있으므로, 이 방법이 수가 커지는 경우에는 잘 되지 않는다. 위에서 13을 홀순이가 만들었지만 짝순이는 최대 사용 횟수 때문에 14를 만들지 못하고 진다.

<br/>

### 입력

첫째 줄에 숫자 게임에서 사용하는 정수의 수 N이, 둘째 줄에는 사용하는 정수가 크기 순으로 주어진다. 셋째 줄에는 최대 사용 횟수 K가 주어진다.

<br/>

### 출력

첫째 줄에 누가 몇 번째 수에서 이겼는지를 출력한다. 예제에서는 짝순이가 14를 못 만들어서, 홀순이가 14에서 이겼다.

<br/>

### 제한

- 1 ≤ N ≤ 1,000
- 1 ≤ K ≤ 50
- 숫자 게임에서 사용하는 정수는 1000보다 작거나 같은 자연수이고, 중복되는 수가 주어지지 않는다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
2
1 3
5

// 예제 출력 1
holsoon win at 14
```

<br/>

### 📕 문제 포인트

1. 크기 순으로 주어진 정수를 활용하여 홀순이, 짝순이 둘이서 1부터 최대로 만들 수 있는 숫자를 만든다.
   - 이때, 최대 K 개의 숫자까지만 사용할 수 있다. (최소한으로 적은 수로 숫자를 만들어야 한다.)
   - 짝수에서 더 이상 만들지 못한다면 홀순이의 승리
   - 홀수에서 더 이상 만들지 못한다면 짝순이의 승리
2. 크기 순으로 정수가 정렬되어 정수 배열이 들어오기 때문에 가장 마지막 정수(가장 큰 수)와 K 개를 곱하여 최대로 나올 수 있는 숫자 크기로 `ch` 배열을 만들었다.
   - 배열은 0부터 시작하기 때문에 계산 편의를 위해 + 1 해주었다.
   - 정수 배열에 숫자 1은 무조건 존재한다는 조건 때문에 초깃값으로 각 index 숫자를 넣어줬다.
3. 이제 정수 배열의 `index=1`부터 정수 배열의 끝까지 순회하며 BFS 탐색을 시작한다.
   - 이때 현재 `ch[현재 정수]`는 `1개`의 수로 만들 수 있기 때문에 `ch[현재 정수] = 1`로 초기화를 해준다.
   - 이제 현재 정숫값 + 정수 배열의 모든 정수 값을 더한 값을 계산한 후 **ch[현재 위치] + 1 보다 크다면 `ch[현재 위치] + 1`로 값을 갱신**해 준다.
     - ch[현재 위치] + 1이 되는 이유는 현재 위치에서 특정 정수를 하나 더 사용하면 해당 값을 만들 수 있기 때문에 해당 정수의 수와 기존 ch에 담겨있는 정수의 수를 비교하여 최솟값으로 값을 갱신해 주는 것이다.
     - 갱신할 때 **queue에도 함께 해당 값을 담아준다.**
4. 모든 BFS 탐색이 끝났다면 다시 반복문을 통해 `1`부터 `ch.length` 길이만큼 반복하며 K 보다 큰 수를 만날 때까지 반복한다.
   - 이때 해당 index를 통해 짝수, 홀수인지 확인하여 홀순이, 짝순이 중 승리를 판별한다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const N = Number(input[0]);
const arr = input[1].split(" ").map(Number);
const K = Number(input[2]);

// 최대로 만들 수 있는 정수 길이만큼 1로 미리 초기화 (1은 무조건 존재)
const ch = Array.from({ length: K * arr.at(-1) + 1 }, (_, idx) => idx);

for (let i = 1; i < N; i++) {
  const num = arr[i];

  ch[num] = 1;

  const queue = [num];

  while (queue.length > 0) {
    const current = queue.shift();

    // 현재 정숫값과 정수 배열의 정수 값을 더한 값을 구해
    // 정수 개수를 비교하여 최솟값으로 갱신해준다.
    for (const a of arr) {
      const currentCount = ch[current];
      const next = current + a;
      const nextCount = ch[next];

      if (currentCount + 1 <= K && currentCount + 1 < nextCount) {
        ch[next] = currentCount + 1;
        queue.push(next);
      }
    }
  }
}

for (let i = 1; i < ch.length; i++) {
  if (ch[i] > K) {
    if (i % 2 === 0) {
      // 홀수 승리
      console.log(`holsoon win at ${i}`);
    } else {
      // 짝수 승리
      console.log(`jjaksoon win at ${i}`);
    }
    return;
  }
}
```
