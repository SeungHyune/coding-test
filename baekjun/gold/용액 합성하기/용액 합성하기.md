# **용액 합성하기**

[문제 링크](https://www.acmicpc.net/problem/14921)

### 문제

홍익대 화학연구소는 다양한 용액을 보유하고 있다. 각 용액은 -100,000,000부터 100,000,000사이의 특성 값을 갖는데, 같은 양의 두 용액을 혼합하면, 그 특성값은 두 용액의 특성값의 합이 된다.

당신은 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 하는데, 각 용액은 10ml시험관에 10ml씩 들어있고, 빈 20ml 시험관이 단 하나 있다. 게다가 용액을 계량할 수 없어서, 두 용액을 섞을 때는 10ml씩 섞어서 20ml로 만드는데, 단 한번밖에 할 수 없다. 그래서 미리 용액의 특성값들을 보고, 어떤 두 용액을 섞을 것인지 정해야 한다.

예를 들어, 연구소에 있는 용액들의 특성값이 [-101, -3, -1, 5, 93]이라고 하자. 이 경우에 특성 값이 각각 -101, 93인 용액을 혼합하면 -8인 용액을 만들 수 있다. 또한 특성값이 5인 용액과 93인 용액을 혼합하면 특성 값이 98인 용액을 만들 수 있다. 모든 가능한 조합을 생각해 보면, 특성값이 2인 용액이 0에 가장 가까운 용액이다.

용액들의 특성값 A1, … ,AN이 오름차순으로 주어졌을 때, 이 중 두 개의 용액을 혼합하여 만들 수 있는 0에 가장 가까운 특성값 B를 출력하시오.

<br/>

### 입력

N

A[1] A[2] … A[N]

<br/>

### 출력

B

<br/>

### 제한

- 2 ≤ N ≤ 100,000
- -100,000,000 ≤ A[i] ≤ 100,000,000
- A[i-1] ≤ A[i]

<br/>

### 예제 입력

```jsx
// 예제 입력 1
5
-101 -3 -1 5 93

// 예제 출력 1
2
```

<br/>

### 📕 문제 포인트

1. 오름차순으로 정렬된 배열의 두 용액을 합성하여 0에 가까운 수를 만들어야 합니다.
2. 이때 `left, right` 포인트를 각각 가장 작은, 가장 큰 수에서 시작하도록 합니다.
3. `while` 문을 통해 `left` 가 `right` 보다 작을 때까지 반복하도록 합니다.
4. 매 반복마다 `arr[right] + arr[left]` 값을 구하고 해당 값의 절댓값과 현재 `answer` 의 절댓값을 비교하여 만약 `arr[right] + arr[left]` 값이 더 작다면 `answer` 값을 갱신해 줍니다.
5. 이후 절댓값으로 변환하지 않은 `arr[right] + arr[left]` 값이 0보다 작다면 left 값을 증가시키고, 0보다 크거나 같다면 right 값을 감소시켜 줍니다.
   - 이유는 0보다 가까운 값을 찾아야 하기 때문에 음수는 더 큰 수를 통해 0에 가깝도록 하고, 양수는 더 작은 값을 통해 0에 가깝도록 해야 합니다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [[N], [...arr]] = input.map((a) => a.split(" ").map(Number));

let [left, right] = [0, N - 1];
let answer = Number.MAX_SAFE_INTEGER;

while (left < right) {
  const diff = arr[right] + arr[left];

  if (Math.abs(answer) > Math.abs(diff)) {
    answer = diff;
  }

  if (diff < 0) {
    left++;
  } else {
    right--;
  }
}

console.log(answer);
```
