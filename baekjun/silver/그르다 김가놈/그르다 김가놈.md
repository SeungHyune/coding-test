# **그르다 김가놈**

[문제 링크](https://www.acmicpc.net/problem/18113)

### 문제

정래는 김밥가게 “그르다 김가놈”에 납품할 김밥을 만드는 김밥 공장을 운영한다. 정래는 김밥 양쪽 끝을 “꼬다리”라고 부른다. 그리고 꼬다리를 잘라낸 김밥을 “손질된 김밥”이라고 부른다.

공장에서는 김밥 *N*개에 대해서, 김밥 꼬다리를 잘라내고 손질된 김밥을 김밥조각으로 만드는 작업을 한다. 꼬다리를 잘라낼 때에는 양쪽에서 균일하게 *K* cm만큼 잘라낸다. 만약 김밥의 길이가 2*K* cm보다 짧아서 한쪽밖에 자르지 못한다면, 한쪽만 꼬다리를 잘라낸다. 김밥 길이가 *K* cm이거나 그보다 짧으면 그 김밥은 폐기한다.

손질된 김밥들은 모두 일정한 길이 *P*로 잘라서 *P* cm의 김밥조각들로 만든다. *P*는 양의 정수여야 한다. 정래는 일정한 길이 *P* cm로 자른 김밥조각을 최소 *M*개 만들고 싶다. *P*를 최대한 길게 하고 싶을 때, *P*는 얼마로 설정해야 하는지 구하시오.

<br/>

### 입력

첫 번째 줄에 손질해야 하는 김밥의 개수 *N,* 꼬다리의 길이 *K*, 김밥조각의 최소 개수 *M*이 주어진다. (1 ≤ *N* ≤ 106, 1 ≤ *K*, *M* ≤ 109, *N*, *K*, *M*은 정수)

두 번째 줄부터 김밥의 길이 *L*이 *N*개 주어진다. (1 ≤ *L* ≤ 109, *L*은 정수)

<br/>

### 출력

김밥조각의 길이 *P*를 최대로 할 때, *P*를 출력한다. 만족하는 *P*가 없는 경우, -1을 출력한다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
3 6 4
20
10
3

// 예제 출력 1
2
```

<br/>

### 📕 문제 포인트

1. 가장 먼저 `[start, end]`의 범위를 설정했습니다.
   - 범위는 `start=1`부터 `end=가장 크기가 큰 김밥`으로 설정했습니다.
2. 이제 이분 탐색 알고리즘을 통해 `mid` 값을 통해 김밥을 잘랐을 때 `M` 개 이상 김밥을 만들 수 있는지 검사했습니다.
3. 김밥을 순회하며 조건에 맞게 꼬다리를 자른 후 `mid` 값으로 김밥을 잘라 잘라진 김밥의 수를 `count` 변수에 저장했습니다.
4. `count` 값이 `M` 보다 같거나 크다면 주어진 `mid` 값으로 김밥을 자를 수 있기 때문에 `answer`에 해당 `mid` 값으로 갱신한 후 더 길이가 크게 자를 수 있는지 검사하기 위해 `start` 값을 `mid + 1`로 범위를 수정해 주었습니다.
5. 반대로 `count` 값이 `M` 보다 작다면 주어진 `mid` 값으로 김밥을 자를 수 없기 때문에 `end` 값을 `mid - 1`로 범위를 변경하여 더 짧은 길이로 김밥을 자를 수 있는지 검사하도록 했습니다.
6. 만약 모든 길이를 탐색했을 때 김밥을 자를 수 없는 경우에는 `answer` 변수의 초깃값 `-1` 이 출력되도록 했습니다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const [N, K, M] = input[0].split(" ").map(Number);
const arr = input.slice(1).map(Number);

const max = Math.max(...arr);

let [start, end] = [1, max];
let answer = -1;

while (start <= end) {
  const mid = Math.floor((start + end) / 2);

  let count = 0;
  for (const a of arr) {
    if (K >= a) {
      continue; // 폐기
    } else if (a < K * 2) {
      // 한쪽 꼬다리만 자름
      count += Math.floor((a - K) / mid);
    } else {
      // 양쪽 꼬다리 자름
      count += Math.floor((a - K * 2) / mid);
    }
  }

  if (count >= M) {
    answer = mid;
    start = mid + 1;
  } else {
    end = mid - 1;
  }
}

console.log(answer);
```
