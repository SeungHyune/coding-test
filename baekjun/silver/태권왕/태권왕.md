# **태권왕**

[문제 링크](https://www.acmicpc.net/problem/14562)

### 문제

태균이는 지금 태권도 겨루기 중이다. 지금은 상대에게 지고 있지만 지금부터 진심으로 경기하여 빠르게 역전을 노리려 한다.

태균이가 현재 할 수 있는 연속 발차기는 두가지가 있다.

1. A는 현재 점수만큼 점수를 얻을 수 있는 엄청난 연속 발차기이다. 하지만 상대 역시 3점을 득점하는 위험이 있다.
2. B는 1점을 얻는 연속 발차기이다.

현재 태균이의 점수 S와 상대의 점수 T가 주어질 때, S와 T가 같아지는 최소 연속 발차기 횟수를 구하는 프로그램을 만드시오.

<br/>

### 입력

첫째 줄에 테스트 케이스의 수 C(1 ≤ C ≤ 100)이 주어진다. 둘째 줄부터 C줄에 걸쳐 테스트 케이스별로 현재 점수 S와 T가 공백을 사이에 두고 주어진다. (1 ≤ S < T ≤ 100)

<br/>

### 출력

각 줄마다 S와 T가 같아지는 최소 연속 발차기 횟수를 출력한다.

<br/>

### 예제 입력

```jsx
// 예제 입력 1
6
10 20
2 7
15 62
10 37
11 50
34 59

// 예제 출력 1
3
3
4
4
5
25
```

<br/>

### 📕 문제 포인트

1. A 선수, B 선수의 점수가 같아지도록 하는 최소한 발차기 횟수를 구하는 문제이다.
   - A 선수는 1번, 2번 발차기를 사용할 수 있다.
     - 1번 : A 선수의 기존 점수를 얻고, B 선수는 3점을 얻는다.
     - 2번: A 선수만 1번을 획득한다.
2. 테스트 케이스 숫자 N 만큼 순회하며 각 선수들의 점수를 통해 두 선수의 점수가 같아지는 경우를 찾습니다.
3. BFS 탐색을 통해 [A 선수 점수, B 선수 점수, 발차기 횟수]를 queue에 담고 1번, 2번 발차기를 사용한다.
   - 이때, A*2 < B+3인 경우에만 1번 발차기를 사용할 수 있으므로 해당 조건을 통과한 경우에만 queue에 다음 순회 배열을 담는다. [A*2, B+3, count+1]
   - A+1 < B인 경우에만 2번 발차기를 사용할 수 있으므로 queue에 담는다.
4. 이렇게 계속 순회하다 최초로 A===B 점수가 같아지는 상황이 온다면 최소 발차기 수를 출력한다.

### 📝 문제 풀이

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

let [[N], ...arr] = input.map((a) => a.split(" ").map(Number));

while (N--) {
  const [S, T] = arr.shift();

  const queue = [[S, T, 0]];

  while (queue.length > 0) {
    const [S, T, count] = queue.shift();

    if (S === T) {
      console.log(count);
      break;
    }

    for (let i = 0; i < 2; i++) {
      if (i === 0) {
        // A의 현재 점수 만큼 점수를 얻는 발차기, 상대도 3점 득점
        if (S * 2 > T + 3) continue;
        queue.push([S + S, T + 3, count + 1]);
      } else if (i === 1) {
        // A만 1점 얻는 발차기
        if (visited[S + 1]) continue;
        queue.push([S + 1, T, count + 1]);
      }
    }
  }
}
```
